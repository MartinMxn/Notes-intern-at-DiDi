# zip(*iterables)函数

## 当zip()函数中只有一个参数时
zip(iterable)从iterable中依次取一个元组，组成一个元组。
```
>>> for i in zip([1,2,'a','v']):
...     print(i)
... 
(1,)
(2,)
('a',)
('v',)
```

## 当zip()函数有两个参数时
zip(a,b)zip()函数分别从a和b依次各取出一个元素组成元组，再将依次组成的元组组合成一个新的迭代器--新的zip类型数据。  
### 要求a与b的维数相同，当两者具有相同的行数与列数时，正常组合对应位置元素即可；
### 当a与b的行数或列数不同时，取两者结构中最小的行数和列数，依照最小的行数和列数将对应位置的元素进行组合；这时相当于调用itertools.zip_longest(*iterables)函数。
```
举例：
m = [[1,2,3], [4,5,6], [7,8,9]]
n = [[2,2,2], [3,3,3], [4,4,4]]
p = [[2,2,2], [3,3,3,]
zip(m, n)将返回([1, 2, 3], [2, 2, 2]), ([4, 5, 6], [3, 3, 3]), ([7, 8, 9], [4, 4, 4])

zip(m, p)将返回([1, 2, 3], [2, 2, 2]), ([4, 5, 6], [3, 3, 3])
```

## zip()函数的应用
矩阵相加减、点乘, 相当于简便了for循环
```
m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
n = [[2, 2, 2], [3, 3, 3], [4, 4, 4]]

# 矩阵点乘
           二维中取出一维数组的pair  一维数组pair取出单个元素处理
print([x*y for a, b in zip(m, n) for x, y in zip(a, b)])
# 矩阵相加,相减雷同
print([x+y for a, b in zip(m, n) for x, y in zip(a, b)])
```

## *zip(*iterables)函数 ？？
*zip()函数是zip()函数的逆过程，将zip对象变成原先组合前的数据。
```
>>> m = [[1, 2, 3],  [4, 5, 6],  [7, 8, 9]]
>>> n = [[2, 2, 2],  [3, 3, 3],  [4, 4, 4]]
>>> print(*zip(m, n))
([1, 2, 3], [2, 2, 2]) ([4, 5, 6], [3, 3, 3]) ([7, 8, 9], [4, 4, 4])
```

## 变量前加星号的意义
```
将列表解开成两个独立的参数，传入函数，还有类似的有两个星号，是将字典解开成独立的元素作为形参。
```
